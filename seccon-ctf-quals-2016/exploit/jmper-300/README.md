# SECCON CTF Quals 2016 : jmper-300

**Category:** Exploit
**Points:** 300
**Solves:** 72
**Description:**

Host : jmper.pwn.seccon.jp
Port : 5656

[jmper](jmper) (SHA1 :78e21967c2de5988876df938559a850e24a000af)
[libc-2.19.so](libc-2.19.so) (SHA1 :8674307c6c294e2f710def8c57925a50e60ee69e)

## Write-up

For this challenge we were given a binary called jmper and the corresponding libc.
I started off by analysing the binary with radare, which I don't describe in detail her,
but I give you c/pseudocode snippets of the import parts.

The binary's main function basically does this:

    int main(int argc, char argv) {
        int ret;
        puts("Welcome to my class."):
        puts("My class is up to 30 people :)");
        myclass = malloc(sizeof(struct myclass));
        jmpbuf = malloc(sizof(struct jmpbuf));
        ret = setjmp(jmpbuf);
        if (ret) {
           mainLoop();
        } else {
           puts("Nice jump! Bye");
        }
        return 0;
    }

Note that it sets a longjump by calling `setjmp`, where the `longjmp struct` is allocated on the heap.
A longjump is basically a cross-function goto, so whenever you call `longjmp` with the particular
`jmpbuf` you will again return from the `setjmp` call, and the return value indicates that a jump has occured.

For the myclass chunk, the following struct is used, which stores pointers to all the students.

    struct class {
        struct stud students[0x1e];
    }

The `mainLoop`, which is called afterwards, has 6 options:

     1. Add student.
     2. Name student.
     3. Write memo
     4. Show Name
     5. Show memo.
     6. Bye :)

Let's see what happens when we add a student, the code looks like this:

    if (studen_num > 0x1d) {
        puts("Exception has occurred. Jump!");
        longjmp(jmpbuf);
    }
    struct stud *stud_tmp = malloc(sizeof(struct stud));
    stud_tmp->name = malloc(0x20);
    myclass->students[stud_num] = stud_tmp;
    stud_num++;


The `stud struct` that is created when a student is added looks like this:

    struct stud {
        uint8_t id;
        char memo_buf[0x20];
        char *name;
    }

Interestingly when you arrive at the maximum number of students, the `longjmp` is triggered
which jumps back to the end of the main function. Remember that the longjump buffer
is stored on the heap, as is a student struct and it's name struct.
The `longjmp struct` looks like this:

    struct jmpbuf {
        uint64_t rbx;
        uint64_t rbp;
        uint64_t r12;
        uint64_t r13;
        uint64_t r14;
        uint64_t r15;
        uint64_t rsp;
        uint64_t rip;
    }

The actual function operates like this:

    <__longjmp>:          mov    r8,QWORD PTR [rdi+0x30]
    <__longjmp+4>:        mov    r9,QWORD PTR [rdi+0x8]
    <__longjmp+8>:        mov    rdx,QWORD PTR [rdi+0x38]
    <__longjmp+12>:       ror    r8,0x11
    <__longjmp+16>:       xor    r8,QWORD PTR [rip+0x209ad9]
    <__longjmp+23>:       ror    r9,0x11
    <__longjmp+27>:       xor    r9,QWORD PTR [rip+0x209ace]
    <__longjmp+34>:       ror    rdx,0x11
    <__longjmp+38>:       xor    rdx,QWORD PTR [rip+0x209ac3]
    <__longjmp+45>:       mov    rbx,QWORD PTR [rdi]
    <__longjmp+48>:       mov    r12,QWORD PTR [rdi+0x10]
    <__longjmp+52>:       mov    r13,QWORD PTR [rdi+0x18]
    <__longjmp+56>:       mov    r14,QWORD PTR [rdi+0x20]
    <__longjmp+60>:       mov    r15,QWORD PTR [rdi+0x28]
    <__longjmp+64>:       mov    eax,esi
    <__longjmp+66>:       mov    rsp,r8
    <__longjmp+69>:       mov    rbp,r9
    <__longjmp+72>:       jmp    rdx

Where RDI contains the `jmpbuf`.
Note that the registers are decrypted like this:

    ror register, 11;
    xor register, magic_number;

In order to overwrite any value in the `jmpbuf`, we have to get hold of the magic_number first,
to be able to encrypt the value correctly.

Let's have a look what the memory layout looks like when running the binary.
When we create 5 students, which turned out the be the number I needed for my exploit, the heap
looks like this (Least significant 12 bit, the rest is random due to ASLR):

    0x010: myclass:
         ---------------------------
          |                        |
          |   students [0x1e]      |
          |                        |
          --------------------------

    0x110: jmpbuf:
          --------------------------
          |                        |
          |   jmpbuf               |
          |                        |
          --------------------------

    0x110: stud1:
          --------------------------
          |                        |
          |  id                    |
          |  memo_buf[0x20]        |
          |  name -----------------|-----
          |                        |    |
          --------------------------    |
                                        |
                                        |
                                        |
    0x220: name1:                       |
          -------------------------- <--|
          |                        |
          |       name_buf         |
          |                        |
          --------------------------

    0x250: stud2:
          --------------------------
          |                        |
          |  id                    |
          |  memo_buf[0x20]        |
          |  name -----------------|-----
          |                        |    |
          --------------------------    |
                                        |
                                        |
                                        |
    0x290: name2:                       |
          -------------------------- <--|
          |                        |
          |       name_buf         |
          |                        |
          --------------------------

    0x2c0: stud3:
          --------------------------
          |                        |
          |  id                    |
          |  memo_buf[0x20]        |
          |  name -----------------|-----
          |                        |    |
          --------------------------    |
                                        |
                                        |
                                        |
    0x300: name3:                       |
          -------------------------- <--|
          |                        |
          |       name_buf         |
          |                        |
          --------------------------

    0x330: stud4:
          --------------------------
          |                        |
          |  id                    |
          |  memo_buf[0x20]        |
          |  name -----------------|-----
          |                        |    |
          --------------------------    |
                                        |
                                        |
                                        |
    0x370: name4:                       |
          -------------------------- <--|
          |                        |
          |       name_buf         |
          |                        |
          --------------------------

    0x3a0: stud5:
          --------------------------
          |                        |
          |  id                    |
          |  memo_buf[0x20]        |
          |  name -----------------|-----
          |                        |    |
          --------------------------    |
                                        |
                                        |
                                        |
    0x3e0: name5:                       |
          -------------------------- <--|
          |                        |
          |       name_buf         |
          |                        |
          --------------------------


The option "2. Name student", dereferences the name pointer and let's you write a maximum of 0x20 bytes.
Furthermore the "show" options just print the content of the particular buffer.
The interesting part is the "3. Write memo" option, which writes 0x21 bytes to the memo buffer of the
student struct, however this is only 0x20 bytes of size. This gives us an one-byte overwrite into the students
name buffer address. Due to the little endian order of x86 we can overwrite the least significant
byte of the heap addresses.

In the first step we overwrite the name pointer of stud2 to point to the position of the name pointer in the
struct of stud3. We cannot use stud1 here be cause we need the second significant byte to be equal.

    0x250: stud2:
          --------------------------
          |                        |
          |  id                    |
          |  memo_buf[0x20]        |
          |  name -----------------|-----
          |                        |    |
          --------------------------    |
                                        |
                                        |
                                        |
    0x290: name2:                       |
          --------------------------    |
          |                        |    |
          |       name_buf         |    |
          |                        |    |
          --------------------------    |
                                        |
    0x2c0: stud3:                       |
          --------------------------    |
          |                        |    |
          |  id                    |    |
          |  memo_buf[0x20]        |    |
          |  name <----------------|----|
          |                        |
          --------------------------

Now we can write any address to stud3's name pointer, by calling "Name Student" with stud2 and afterwards use it for arbitrary
read/writes by triggering "Name student"/"Show name" with stud3.

First of all we want to know the second least significant byte of the heap address, because ASLR affects the
first 4 bits of it, and we can only write byte wise to the memory.
The Problem here is that stud3's name address is 0x300 thereby we have a null-byte at the LSB, when calling "Show name" directlly,
terminates the output via fprintf immediately. To circumvent this we write an 'A' to the LSB first and then read it.

Now we can write two byte offsets. The basic idea for the exploit is to overwrite the stored longjump buf with a different
RIP and trigger the longjump, which will continue the execution at our chosen address.
Therefore we leak the stored RIP in the buf, whose real value is known to us cause the binary is not position independent itself.
This can simply be done by writing the offset of the RIP address to stud3's name address.

    0x110: jmpbuf:
          --------------------------
          |                        |
          |  0x00: ???             |
          |  0x08: RBP             |
          |  0x10: R12             |
          |  0x18: R13             |
          |  0x20: R14             |
          |  0x28: R15             |
          |  0x30: RSP             |
          |  0x38: RIP <----------------|
          |                        |    |
          --------------------------    |
                                        |
    ...                                 |
                                        |
                                        |
    0x290: name2:                       |
          --------------------------    |
          |                        |    |
          |       name_buf         |    |
          |                        |    |
          --------------------------    |
                                        |
    0x2c0: stud3:                       |
          --------------------------    |
          |                        |    |
          |  id                    |    |
          |  memo_buf[0x20]        |    |
          |  name  ----------------|----|
          |                        |
          --------------------------



With the leaked rip, we can calculate the magic_num, by rotating it and xoring with the known RIP value.

The idea for the exploit is to manipulate the longjump buffer in a way that instead of returning to the main function,
we return to `system(/bin/sh)`.
First of all we want to make set the first argument to the returning function to point to /bin/sh. Unfortunately the provided
libc doesn't contain that string, neither does the binary. This means we have to write the string to the memory first,
which shouldn't be a problem, as we have multiple options for that. However, we still need to get the address of the string,
into RDI. Therefore, we have a look at which address RDI is pointing after the `longjmp` call, which is the same value,
that was used for the `longjmp` arguments, which is nothing else but the longjump buf. Furthermore, the first 8 bytes of
the buffer are not necessary for us anyways, which means we can just write our /bin/sh string there and have perfectly
RDI pointing to it directly, awesome! Therefore, we write the correct offset to stud3's name address:


    0x110: jmpbuf:
          --------------------------
          |                        |
          |  0x00: ??? <-----------|----|
          |  0x08: RBP             |    |
          |  0x10: R12             |    |
          |  0x18: R13             |    |
          |  0x20: R14             |    |
          |  0x28: R15             |    |
          |  0x30: RSP             |    |
          |  0x38: RIP             |    |
          |                        |    |
          --------------------------    |
                                        |
    ...                                 |
                                        |
                                        |
    0x290: name2:                       |
          --------------------------    |
          |                        |    |
          |       name_buf         |    |
          |                        |    |
          --------------------------    |
                                        |
    0x2c0: stud3:                       |
          --------------------------    |
          |                        |    |
          |  id                    |    |
          |  memo_buf[0x20]        |    |
          |  name  ----------------|----|
          |                        |
          --------------------------

Now we can write /bin/sh to the longjump buffer by calling "Name student" with stud3.

In the last step we have to want to overwrite to stored RIP with the address of `system@glibc`. Therefore, we set the address of the
stud3' name pointer to address of `getchar` in the GOT, which is known due to missing position independence.



    0x0601fc0: getchar@got <------------|
                                        |
    ...                                 |
                                        |
    0x2c0: stud3:                       |
          --------------------------    |
          |                        |    |
          |  id                    |    |
          |  memo_buf[0x20]        |    |
          |  name  ----------------|----|
          |                        |
          --------------------------

With the known address of system in the libc, we have everything we need, but we destroyed our arbitrary read/write, by overwriting
the heap address with one of the GOT. We could leak a full heap address in the first place, but I decided to just use another pair
of students to get the same setup as before, stud4 and stud5. Overflowing stud4's memo, thereby pointing stud4's name to stud5's name address,
provides us with the old setup.
Now we let stud5's name address point to the RIP of the lonjump buffer again:


    0x110: jmpbuf:
          --------------------------
          |                        |
          |  0x00: /bin/sh         |
          |  0x08: RBP             |
          |  0x10: R12             |
          |  0x18: R13             |
          |  0x20: R14             |
          |  0x28: R15             |
          |  0x30: RSP             |
          |  0x38: RIP <----------------|
          |                        |    |
          --------------------------    |
                                        |
    ...                                 |
                                        |
                                        |
    0x370: name4:                       |
          --------------------------    |
          |                        |    |
          |       name_buf         |    |
          |                        |    |
          --------------------------    |
                                        |
    0x3a0: stud5:                       |
          --------------------------    |
          |                        |    |
          |  id                    |    |
          |  memo_buf[0x20]        |    |
          |  name  ----------------|----|
          |                        |
          --------------------------


Now we just calculate the right RIP value be xoring `system@glibc` with the magic_num and rotating it to the left.
Finally we write the resulting quad word to the stored RIP position.
All thats left to do is adding students until the `longjmp` is triggered and `system(/bin/sh)` is called.


Here is the final exploit in action:

    [+] Starting local process './jmper': Done
    [*] Created stud 0
    [*] Created stud 1
    [*] Created stud 2
    [*] Created stud 3
    [*] Created stud 4
    [*] Found jumpbuf offset: 7110
    [*] Get secret xor word
    [*] Found stored rip: e79196934e07e982
    [*] Found secret xor: f4c173c8cb09ab32
    [*] Overwrite stored rbx with /bin/sh'
    [*] Overwrite stored rip with system@libc
    [*] Found getchar @ 7f51413905d0
    [*] Found libc_base @ 7f5141321000
    [*] Found system @ 7f51413604d0
    [*] New rip: 1933147f5fc5e982
    [*] Switching to interactive mode
    
    Exception has occurred. Jump!
    $ cat flag
    SECCON{3nj0y_my_jmp1n9_serv1ce}

Rather easy challenge, that what was fun to solve, thanks to the author!:-)

## Other write-ups and resources

* https://github.com/0x90r00t/Write-Ups/blob/master/Seccon/checker/solve.py
* https://github.com/Inndy/ctf-writeup/tree/master/2016-seccon/jmper
* https://github.com/0x90r00t/Write-Ups/blob/master/Seccon/jmper/solve.py
* https://github.com/DaramG/ctf-writeup/tree/master/2016_seccon/jmper
* http://s0ngsari.tistory.com/entry/SECCON-CTF-2016-jmper
